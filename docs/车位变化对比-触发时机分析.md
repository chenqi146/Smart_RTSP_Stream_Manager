# 车位/车辆变化对比 — Sequential Thinking 分析

## 分析目标

- 车辆/车位变化对比是否**只在「生成任务」时**做？
- **以前已执行完成的任务**的截图是否会再做对比？

---

## 步骤 1：变化对比的入口是谁？

**结论**：变化对比由 **车位变化检测 Worker** 执行，入口是 `app/background/parking_change_worker.py` 中的 `process_pending_screenshots()`。

- 该函数被 **定时后台任务** 周期性调用（`main.py` 中 `start_parking_change_detector()`，轮询间隔内反复执行）。
- Worker 内部会：读 `screenshots` 表、做 YOLO 检测、与上一张截图对比、写 `parking_changes` / `parking_change_snapshots`，并更新 `screenshots.yolo_status`。

**相关代码**：

- `app/main.py`：启动 `start_parking_change_detector()`，循环调用 `process_pending_screenshots(batch_size=10)`。
- `app/background/parking_change_worker.py`：`process_pending_screenshots()` 实现具体检测与对比逻辑。

---

## 步骤 2：Worker 处理的是哪些截图？

**结论**：**只处理 `screenshots` 表中 `yolo_status == 'pending'` 的记录。**

```python
# parking_change_worker.py 第 1352–1358 行
shots: List[Screenshot] = (
    db.query(Screenshot)
    .filter(Screenshot.yolo_status == "pending")
    .order_by(Screenshot.id.asc())
    .limit(batch_size)
    .all()
)
```

- 没有「按任务创建时间」「按任务状态」等条件，**唯一筛选条件就是 `yolo_status == "pending"`**。
- 处理完后会把该条记录的 `yolo_status` 更新为 `"done"` 或 `"failed"`，因此同一条截图**只会被对比一次**，之后不会再被 Worker 捞取。

---

## 步骤 3：谁会把截图设为 pending？

**结论**：**只有「生成任务并成功截图」时**会写入/更新 `screenshots`，并使其进入 pending。

- 写库逻辑在 `services/screenshot.py` 的 `capture_frame()` 中，且仅在 **保存图片成功** 且 **传入 `db` 和 `task_id`** 时执行。
- `capture_frame()` 的调用链：主任务执行截图流程（如 `_process_single_segment`）→ 截图成功 → 调用 `capture_frame(..., db=db, task_id=task_id, to_rel=_to_rel)`。

具体两种情形：

1. **该 task_id 已有截图记录**  
   - 更新 `file_path`、去重相关字段，并**显式设置**  
   - `existing_shot.yolo_status = "pending"`  
   - 即：同一任务再次截图时，会重新进入「待对比」队列。

2. **该 task_id 没有截图记录**  
   - 新建 `Screenshot(task_id=task_id, file_path=rel)`。  
   - 模型中 `yolo_status` 的默认值为 `"pending"`（`models.py` 中 Column default=`"pending"`），因此新记录天然是 pending。

**结论**：  
- 进入对比队列的截图，**全部**来自「某次任务执行并成功截图」的那一时刻。  
- 没有任何逻辑会「把很久以前已完成任务的截图再次设为 pending」或「按任务完成时间再扫一遍历史截图」。

---

## 步骤 4：以前执行完成的任务的图片会不会再做对比？

**结论**：**不会。** 以前已经执行完成的任务，其截图一旦被 Worker 处理过，就不会再参与对比。

- 每条 `screenshots` 记录只有在 `yolo_status == "pending"` 时才会被 `process_pending_screenshots` 处理。
- 处理一次后，`yolo_status` 会变为 `"done"` 或 `"failed"`，之后查询条件 `yolo_status == "pending"` 再也匹配不到这条记录。
- 没有发现任何代码会把已 `done`/`failed` 的记录重新置为 `pending`（除非该任务**再次执行截图**，走的是「更新已有记录并设 pending」的分支）。

因此：

- **「以前执行完成的任务的图片」** 若指：任务早就跑完，且对应截图已被 Worker 处理过 → 这些图片**不会**再做对比。
- **「只有在生成任务的时候做对比」** 可以更精确地说成：**只有在「任务执行并成功生成截图」时，该截图才会被标记为 pending 并进入对比队列；对比只发生一次，之后不会对同一张图重复做对比。**

---

## 步骤 5：与「每分钟截图」的关系

- 车位变化对比依赖的是 **`screenshots` 表**（主任务 10 分钟段截图），由 `capture_frame(..., db=db, task_id=task_id)` 写入。
- **每分钟截图** 写入的是 **`minute_screenshots` 表**，且 `_generate_minute_screenshot` 里调用 `capture_frame(..., db=None, task_id=None)`，**不写 `screenshots` 表**。
- 因此：**每分钟截图不会产生新的 `screenshots` 记录，也不会参与车位变化对比。** 变化对比只针对「主任务」的那张截图。

---

## 总结表

| 问题 | 结论 |
|------|------|
| 变化对比是否只有在「生成任务」时做？ | **是。** 只有任务执行并成功截图时，才会写入/更新 `screenshots` 并设为 `yolo_status='pending'`，对比仅针对这些 pending 记录。 |
| 以前执行完成的任务的图片会不会再做对比？ | **不会。** 每条截图被 Worker 处理一次后变为 `done`/`failed`，不再满足 `yolo_status=='pending'`，不会被再次处理。 |
| 谁决定某张图要不要被对比？ | **唯一依据是 `screenshots.yolo_status == 'pending'`。** 只有截图刚生成（或同任务再次截图）时会被设为 pending。 |
| 每分钟截图会参与变化对比吗？ | **不会。** 每分钟截图只写入 `minute_screenshots`，不写入 `screenshots`，不参与车位变化对比。 |

---

## 相关代码位置速查

- Worker 入口与轮询：`app/main.py` — `start_parking_change_detector()`、`process_pending_screenshots` 调用。
- 待处理截图查询：`app/background/parking_change_worker.py` — `process_pending_screenshots()` 内 `filter(Screenshot.yolo_status == "pending")`。
- 写库与设为 pending：`services/screenshot.py` — `capture_frame()` 内对 `Screenshot` 的创建/更新及 `yolo_status = "pending"`。
- 模型默认值：`models.py` — `Screenshot.yolo_status` 的 `default="pending"`。
- 主任务截图调用：`app/main.py` — `_process_single_segment()` → `capture_frame(..., db=db, task_id=task_id)`。
